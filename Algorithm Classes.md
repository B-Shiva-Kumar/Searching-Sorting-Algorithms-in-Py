## Algorithm Basics :

1. Algorithm is a step-by-step procedure, which defines a set of instructions to be executed in a certain order to get the desired output.
2. an algorithm can be implemented in more than one programming language.

* From the data structure point of view, following are some important categories of algorithms −

`Search` − Algorithm to search an item in a data structure.

`Sort` − Algorithm to sort items in a certain order.

`Insert` − Algorithm to insert item in a data structure.

`Update` − Algorithm to update an existing item in a data structure.

`Delete` − Algorithm to delete an existing item from a data structure.



**Algothim Classes :**

1. `Divide & Conquer` : Divides the problem into sub parts & solves each one seperately.

The following computer algorithms are based on divide-and-conquer programming approach −

1. Merge Sort
2. Quick Sort
3. Binary Search
4. Strassen's Matrix Multiplication
5. Closest pair (points)

There are various ways available to solve any computer problem, but the mentioned are a good example of divide and conquer approach.




2. `Dynamic Programming` : Divides the problem into subparts, remembers the results of the subparts & applies it to similar ones.

The following computer problems can be solved using dynamic programming approach −

1. Fibonacci number series
2. Knapsack problem
3. Tower of Hanoi
4. All pair shortest path by Floyd-Warshall
5. Shortest path by Dijkstra
6. Project scheduling

Dynamic programming can be used in both top-down and bottom-up manner. And of course, most of the times, referring to the previous solution output is cheaper than recomputing in terms of CPU cycles.



3. `Greedy Algorithms` : Involves taking the easiest step while solving a problem without worrying about the complexity of the future steps.

Most networking algorithms use the greedy approach. Here is a list of few of them −

1. Travelling Salesman Problem
2. Prim's Minimal Spanning Tree Algorithm
3. Kruskal's Minimal Spanning Tree Algorithm
4. Dijkstra's Minimal Spanning Tree Algorithm
5. Graph - Map Coloring
6. Graph - Vertex Cover
7. Knapsack Problem
8. Job Scheduling Problem

There are lots of similar problems that uses the greedy approach to find an optimum solution.

